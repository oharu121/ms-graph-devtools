# Dev Notes - November 20, 2025

## Major API Refactor: AWS SDK-Style Global Instance Pattern

### Context & Problem
User wanted to use the library with a cleaner global instance pattern:
```typescript
Azure.config({...});
export default Azure;

// Then use anywhere
await Azure.outlook.sendMail({...});
```

Previously, users had to manually instantiate services even after calling `Azure.config()`:
```typescript
Azure.config({...});
const outlook = new Outlook(); // Extra step, redundant
await outlook.sendMail({...});
```

User feedback: "I don't even want to Azure.init() during setup. As I already called Azure.config() and export the global instance, extra init just makes no sense to me"

**They were absolutely right** - it was redundant and confusing.

### Solution: Lazy-Loaded Service Getters

Added static getters to the `Azure` class that return singleton service instances:

```typescript
class Azure {
  private static _outlook?: Outlook;
  private static _calendar?: Calendar;
  private static _teams?: Teams;
  private static _sharePoint?: SharePoint;

  static get outlook(): Outlook {
    if (!this._outlook) {
      this._outlook = new Outlook();
    }
    return this._outlook;
  }

  // ... similar for teams, calendar, sharePoint
}
```

### Key Design Decisions

1. **Lazy Loading**: Services are only instantiated when first accessed
   - Better performance - unused services aren't created
   - Still tree-shakable - bundlers can remove unused code

2. **Singleton Pattern**: Same instance returned on multiple accesses
   - Consistent with AWS SDK behavior
   - Prevents multiple auth instances

3. **Reset on Config Change**: Calling `Azure.config()` clears all cached instances
   - Ensures new config is picked up by all services
   - Prevents stale configuration bugs

4. **Backward Compatible**: Old pattern (`new Outlook()`) still works
   - Power users can still instantiate services directly
   - Useful for multiple configurations or dependency injection
   - No breaking changes for existing code

### Implementation Details

**Files Modified:**
- `src/index.ts` - Added service getters and private static fields
- `README.md` - Complete rewrite with new API examples
- `CHANGELOG.md` - Documented API improvement and migration guide

**Files Added:**
- `tests/azure-api.test.ts` - Comprehensive test suite for new API

### Testing
- ✅ TypeScript compilation passes
- ✅ Type checking passes
- ✅ Created vitest test suite covering:
  - Service getter functionality
  - Singleton behavior
  - Lazy loading
  - Reset functionality
  - Integration patterns

### Migration Path

**Recommended Pattern (New):**
```typescript
// config/azure.ts
import Azure from 'ms-graph-devtools';

Azure.config({
  clientId: process.env.AZURE_CLIENT_ID,
  clientSecret: process.env.AZURE_CLIENT_SECRET,
  tenantId: process.env.AZURE_TENANT_ID,
  tokenProvider: async (callback) => {
    return await Playwright.getAzureCode(callback);
  },
});

export default Azure;
```

```typescript
// anywhere in app
import Azure from './config/azure';

await Azure.outlook.sendMail({...});
await Azure.teams.postMessage({...});
```

**Advanced Pattern (Still Supported):**
```typescript
import { Outlook, Teams } from 'ms-graph-devtools';

const outlook = new Outlook({...});
const teams = new Teams({...});
```

### Benefits Achieved

1. **Cleaner API** - One config call, then direct service access
2. **AWS SDK Familiarity** - Developers know this pattern
3. **Better DX** - IDE autocomplete shows all available services
4. **No Breaking Changes** - Old code still works
5. **Performance** - Lazy loading means unused services aren't created
6. **Testability** - `Azure.reset()` makes testing easier

### Documentation Updates

Rewrote major sections of README:
- **Quick Start** - Prominently features global instance export pattern as best practice
- **Best Practices Section** (NEW) - Dedicated section explaining:
  - Global instance export pattern (✅ GOOD vs ❌ BAD examples)
  - File structure recommendations
  - Environment variable usage
  - TypeScript validation patterns
- **Features Section** - Updated to highlight "Global instance pattern" and "Zero config imports"
- **Three-Tier User System** - All examples use new API
- **Service Classes** - Shows both patterns (global recommended, direct advanced)
- **Service Usage Patterns** - Global instance pattern first
- **FAQ Section** - New Q&A emphasizing export pattern as #1 recommendation
- **Troubleshooting** - Updated for new API

**Key messaging**: "Export a configured global instance - this is the best practice for 95% of use cases"

All examples now showcase the recommended pattern:
```typescript
// config/azure.ts - Configure once
import Azure from 'ms-graph-devtools';
Azure.config({...});
export default Azure;

// everywhere else - import and use
import Azure from './config/azure';
await Azure.outlook.sendMail({...});
```

### User Feedback
User was asking for honest opinion on API design. After analyzing the codebase:

**My recommendation**: Go with AWS SDK-style (global instance) because:
1. README already showed this pattern aspirationally
2. Most users want simplicity (configure once, use everywhere)
3. User's use case was script automation - perfect fit
4. Better developer experience

The hybrid approach (offering `Azure.config()` but requiring manual instantiation) was confusing. Now it's consistent and intuitive.

### Future Considerations

- Could add more utility methods to Azure class (e.g., `Azure.testConnection()`)
- Consider adding `Azure.services` property that returns all service instances
- May want to add JSDoc examples showing both patterns for each service
- Consider adding initialization hooks (onConfigChange, onServiceCreated)

### Lessons Learned

1. **Listen to user intuition** - When user says "this doesn't make sense", they're usually right
2. **AWS SDK set the standard** - Don't reinvent familiar patterns
3. **Backward compatibility** - Can improve API without breaking existing code
4. **Lazy loading + Singletons** - Powerful combination for global instances
5. **Documentation matters** - Updated README makes new pattern clear

### Node.js 18 CI Failure Fix

**Issue**: Tests failed on Node 18 in GitHub Actions due to `whatwg-url`/`jsdom` compatibility issues
- Error: `Cannot read properties of undefined (reading 'get')` in `webidl-conversions`
- Root cause: Node 18 doesn't fully support URL globals in test environments

**Solution**: Dropped Node.js 18 support
- Updated `package.json` engines to `>=20.0.0`
- Removed Node 18 from CI test matrix
- Node 18 reached EOL on April 30, 2025 anyway
- Updated CHANGELOG to document breaking change

**Files Changed**:
- `package.json` - Updated engines field
- `.github/workflows/ci.yml` - Removed node 18 from matrix
- `CHANGELOG.md` - Added breaking change notice

### Next Steps

User needs to:
1. ✅ Review changelog and dev notes (this file)
2. ✅ Version bumped to 1.2.0 (minor - new features + breaking change)
3. Test in their actual project
4. Consider publishing new version

### Related Files
- [src/index.ts](../src/index.ts) - Main API implementation
- [tests/azure-api.test.ts](../tests/azure-api.test.ts) - Test suite
- [README.md](../README.md) - Updated documentation
- [CHANGELOG.md](../CHANGELOG.md) - Migration guide
